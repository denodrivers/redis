#!/usr/bin/env deno run --allow-read --allow-write --allow-run

const encoder = new TextEncoder();
const decoder = new TextDecoder();

interface Node {
  kind: string;
  name: string;
}

async function doc(fileName: string): Promise<Array<Node>> {
  const deno = Deno.run({
    cmd: [Deno.execPath(), "doc", "--json", fileName],
    stdout: "piped",
  });
  try {
    const out = await Deno.readAll(deno.stdout);
    return JSON.parse(decoder.decode(out));
  } finally {
    deno.stdout.close();
    deno.close();
  }
}

async function fmt(content: string): Promise<string> {
  const deno = Deno.run({
    cmd: [Deno.execPath(), "fmt", "-"],
    stdin: "piped",
    stdout: "piped",
  });
  try {
    await Deno.writeAll(deno.stdin, encoder.encode(content));
    deno.stdin.close();
    const formattedContent = decoder.decode(await Deno.readAll(deno.stdout));
    return formattedContent;
  } finally {
    deno.stdout.close();
    deno.close();
  }
}

const files = [...Deno.readDirSync(".")].filter((f) => {
  const name = f.name;
  if (!name || name === "mod.ts") return false;
  return name.endsWith(".ts") && !name.endsWith("_test.ts") &&
    !name.endsWith(".d.ts");
}).map((f) => f.name).sort();
let content = `// Generated by tools/make_mod.ts. Don't edit.\n`;

// Expose public functions from redis.ts.
{
  const fileName = "redis.ts";
  const functions = (await doc(fileName)).filter((node) => {
    return node.kind === "function";
  }).map((node) => node.name);
  content += `export { ${functions.join(",")} } from "./${fileName}";\n`;
}

// Expose types from *.ts.
for (const f of files) {
  const types = (await doc(f)).filter((node) => {
    return node.kind === "interface" || node.kind === "typeAlias";
  }).map((node) => node.name);
  if (types.length > 0) {
    content += `export type { ${types.join(",")} } from "./${f}"\n`;
  }
}
Deno.writeFileSync("mod.ts", encoder.encode(await fmt(content)));
