#!/usr/bin/env deno run --allow-read --allow-write --allow-run

import { readAll } from "../vendor/https/deno.land/std/streams/read_all.ts";
import { writeAll } from "../vendor/https/deno.land/std/streams/write_all.ts";

const encoder = new TextEncoder();
const decoder = new TextDecoder();

interface Node {
  kind: string;
  name: string;
}

async function doc(fileName: string): Promise<Array<Node>> {
  const deno = Deno.run({
    cmd: [Deno.execPath(), "doc", "--json", fileName],
    stdout: "piped",
  });
  try {
    const out = await readAll(deno.stdout);
    return JSON.parse(decoder.decode(out));
  } finally {
    deno.stdout.close();
    deno.close();
  }
}

async function fmt(content: string): Promise<string> {
  // deno-lint-ignore no-deprecated-deno-api
  const deno = Deno.run({
    cmd: [Deno.execPath(), "fmt", "-"],
    stdin: "piped",
    stdout: "piped",
  });
  try {
    await writeAll(deno.stdin, encoder.encode(content));
    deno.stdin.close();
    const formattedContent = decoder.decode(await readAll(deno.stdout));
    return formattedContent;
  } finally {
    deno.stdout.close();
    deno.close();
  }
}

function collectSourceFilesInRootDir(): Array<string> {
  return [...Deno.readDirSync(".")].filter((f) => {
    const name = f.name;
    if (!name || name === "mod.ts") return false;
    return name.endsWith(".ts") && !name.endsWith("_test.ts") &&
      !name.endsWith(".d.ts");
  }).map((f) => f.name);
}

const files = [...collectSourceFilesInRootDir(), "protocol/mod.ts"].sort();
let content = `// Generated by tools/make_mod.ts. Don't edit.\n`;

// Expose public variables from protocol/mod.ts
{
  const fileName = "protocol/mod.ts";
  const variables = (await doc(fileName)).filter((node) => {
    return node.kind === "variable";
  }).map((node) => node.name);
  content += `export { ${variables.join(",")} } from "./${fileName}";\n`;
}

// Expose public functions from redis.ts.
{
  const fileName = "redis.ts";
  const functions = (await doc(fileName)).filter((node) => {
    return node.kind === "function";
  }).map((node) => node.name);
  content += `export { ${functions.join(",")} } from "./${fileName}";\n`;
}

// Expose public classes from errors.ts
{
  const fileName = "errors.ts";
  const classes = (await doc(fileName)).filter((node) => {
    return node.kind === "class";
  }).map((node) => node.name);
  content += `export { ${classes.join(",")} } from "./${fileName}";\n`;
}

// Expose types from *.ts.
for (const f of files) {
  const types = (await doc(f)).filter((node) => {
    return node.kind === "interface" || node.kind === "typeAlias";
  }).map((node) => node.name);
  if (types.length > 0) {
    content += `export type { ${types.join(",")} } from "./${f}"\n`;
  }
}
Deno.writeFileSync("mod.ts", encoder.encode(await fmt(content)));
